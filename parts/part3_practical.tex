\clearpage
\chapter{Практическая часть}

\section{Архитектура и основные этапы разработки}
Для реализации предлагаемого подхода архитектура проекта размещается полностью в облаке AWS (Amazon Web Services), что позволяет использовать все доступные и постоянно обновляющиеся возможности облачных решений. Создаваемое приложение в рамках работы позволяет повысить эффективность управления цифровыми активами для бизнес-процессов компании, а также усовершенствовать способы хранения большого объёма структурированных данных, системная обработка которых необходима для ежедневной работы (загрузка, описание, организация, быстрый поиск, распространение). Рассмотрим процесс решения данной задачи, используя современные возможности cloud-технологий и обеспечивая выполнение всех требований к хранению корпоративных данных. 

\subsection{Обзор архитектуры приложения}
Общее описание архитектуры данной DAM"=системы представлено на рисунке \ref{highLevelOverview}.
\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.32]{images/HighLevelOverview.png}
    \caption{-- Общее описание архитектуры DAM"=системы}
    \label{highLevelOverview}
\end{figure}

Для создания этого Веб-приложения использовался фреймворк React, весь код написан на языке Typescript, который обеспечивает строгую типизацию и позволяет создавать структуры для облегчения поддержки и дальнейшей модернизации всего фронтенда. Для загрузки файлов в DAM-систему в приложении предусмотрено облачное хранилище для любых типов объектов. Для работы с метаданными, правами пользователей и остальными элементами DAM"=системы данное приложение использует NoSQL базу данных, разработанную компанией Amazon – DynamoDB. Использование правильного моделирования данных позволяет хранить разные структуры в одной таблице. Более детально и подробно устройство схемы базы данных будет рассмотрено в структуре бекэнда.

Архитектура этого веб-приложения не имеет ни одного сервера, нет облачных компьютеров, к которым была бы необходимость подключаться и управлять какими-либо аспектами приложения. Все используемые сервисы управляются и поддерживаются AWS, что позволяет при разработке уделять время только созданию ключевых частей программы, таких как: фронтенд, написанный на Typescript, Lambda функции на Python, принимающие REST-запросы через API Gateway и работающие с DynamoDB, AWS SDK для NodeJS, позволяющий управлять файлами в облаке, находящимися в S3 (simple storage service), что тоже является Serverless сервисом.

\subsection{Этапы разработки и компоненты приложения} 

Перечислим компоненты разработанной DAM"=системы, которые являлись различными стадиями в процессе реализации решения задачи, поставленной в ВКР.

Пользовательский интерфейс для управления и доступа к Digital Asset Management системе. Веб-приложение, созданное при помощи фреймворка React. AWS-сервис Amplify для непосредственного размещения сайта (на данный момент с тестовым бесплатным доменом, который выдаёт Amazon cloud провайдер).

Хранилище загружаемых в DAM"=систему файлов - AWS S3 service, позволяющий хранить файлы любого размера и предоставляющий API для их загрузки и скачивания. Использование AWS JavaScript SDK для работы с S3 сервисом на стороне пользовательского интерфейса.

Не реляционная база данных AWS DynamoDB для быстрого управления метаданными файлов, информации о smart-папках, структурирования файлов и правами пользователей. Разработка API приложения, создание запросов при работе пользователя с DAM"=системой через интерфейс. Обработка запросов на стороне облака с помощью AWS API Gateway. Разработка AWS Lambda-функций на языке Python для работы с базой данных - обращения, возвращения запрашиваемой информации и внесения изменений.

Программный код для автоматизации запуска DAM"=системы. Реализация подхода Infrastructure as code, создание AWS CloudFormation template, где описывается вся инфраструктура, необходимая для работы системы управления цифровыми активами. Написание Shell script и Python script для автоматизации запуска процесса сборки и развертывания приложения в облаке AWS.

\noindent 

\subsection{Пользовательский интерфейс}

Рассмотрим более подробно как устроен фронтенд разработанного приложения. Благодаря тому, что тип веб-сайта в данном случае Single Page Application, в один момент времени загружаются лишь только необходимые элементы страницы, которые запрашивает пользователь из-за чего ускоряется обработка запросов, и отображение самого контента на странице браузера.

Весь код был выполнен на языке TypeScript что позволяет легко понимать как работает тот или иной компонент приложения и что ему нужно. Рассмотрим все части более подробно.

После перехода по основной ссылке (без параметров), пользователь попадает на первую страницу: Home.tsx. Здесь находится лишь текст приветственного сообщения и кнопка перехода на страницу авторизации (которая предоставляется сервисом AWS Amplify). Также стоит заметить, что благодаря использованию библиотек для React отображения всех компонентов, всегда есть возможность полностью поменять оформление сайта без каких-либо крупных изменений в коде, это значительно ускоряет процесс разработки приложения.
В компоненте App.tsx расположена вся конфигурация приложения - роутеры различных путей ссылок и верхняя панель управления приложением: кнопки перехода на главную страницу, на страницу личного профиля и на элемент просмотра всех загруженных в облако файлов.

Все остальные страницы веб-сайта могут быть доступны только авторизированным пользователям, поэтому путь к ним будет состоять из <URL>/private/<Название страницы>

Первой страницей, которую увидит пользователь, будет PersonalPage.tsx (рисунок \ref{personalPage}).
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.63]{images/ui/1_PersonalPage.jpg}
    \caption{-- Персональная страница пользователя}
    \label{personalPage}
\end{figure}

На ней находятся: панель управления личным профилем, поле для создания нового кластера, кнопка для перехода на страницу просмотра доступных пользователю smart-папок, таблица созданных кластеров и кнопка удаления всего пользовательского профиля. Также на этой странице указывается какое количество мегабайт использовано для хранения загруженных файлов.
Если же роль пользователя имеет привилегии администратора, то дополнительно будет отображаться компонент для отправки запроса напрямую в базу данных.
При подключении этой страницы происходит установка JWT токена авторизации (об этом будет рассказано далее), производится запрос в базу данных для получения всех smart-папок пользователя, а также запрос на получение информации о размере использованного хранилища.

При нажатии на отображаемый в списке кластер, произойдет переход на страницу просмотра соответствующей smart-папки: ClusterOverview.tsx (рисунок \ref{clusterPage}).
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.6]{images/ui/2_ClusterPage.jpg}
    \caption{-- Страница просмотра кластера}
    \label{clusterPage}
\end{figure}

Идентификатор smart-папки извлекается из url параметров, затем загружается токен авторизации, происходит запрос в базу данных для получения прав этого пользователя на указанный кластер, метаданных всех файлов добавленных в этот кластер и пользователей, которым также доступен этот кластер.

Для поиска и просмотра всех загруженных файлов существует страница SearchFiles.tsx как показано на рисунке \ref{filesPage}.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.53]{images/ui/3_FilesPage.jpg}
    \caption{-- Страница просмотра загруженных пользователем файлов}
    \label{filesPage}
\end{figure} 

Здесь происходит получение всех файлов текущего пользователя, его кластеров и smart-папок, к которым есть доступ. Функционал данной страницы позволяет управлять размещением файлов по всем кластерам, осуществить поиск по характеристикам и удалять файлы из облака.
Благодаря использованию React был создан компонент FileOverview.tsx, который включает в себя всё представление отображения информации о файле. Это повышает инкапсуляцию кода, ускоряет разработку программы и позволяет разделить логику для лучшего понимания.
Также все основные функции запросов и обработки ответа от базы данных были вынесены в отдельный интерфейс componentsFunctons.ts, например: получение всех кластеров пользователя, метаданных файлов и функция скачивания файла из облака, использующая AWS SDK для JavaScript. Все типы данных, находящиеся в DynamoDB описаны как интерфейсы в databaseTables.ts, что позволяет видеть все поля объектов и открывает новые возможности при работе с типизированным кодом. Всё это было достигнуто благодаря использованию языка программирования TypeScript.

Наиболее удачной реализацией достоинств этого языка является написанная полиморфная функция для создания http запросов и обработки ответа, используя указанный тип объекта. Асинхронная функция makeFetch<T>
(fetchParams: FetchParams): Promise<T> принимает в качестве параметра объект типа FetchParams, где указывается url, метод запроса, токен авторизации и тело запроса (если таковое имеется). Возвращаемый результат зависит от указанного типа T, что позволяет эффективно интегрировать эту функцию в код приложения.

\subsection{Архитектура фронтенда, аунтефикации и REST API}
На рисунке \ref{authentication} изображена структура аунтефикации запросов с клиентской части приложения.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.65]{images/Authentication.png}
    \caption{ -- Архитектура аунтефикации пользовательских запросов}
    \label{authentication}
\end{figure}

Для аунтефикации пользователей данное приложение использует JWT токены, которые предоставляет AWS сервис Cognito. Также этот сервис даёт возможность быстрого создания и настройки интерфейса для регистрации новых пользователей с проверкой почты. Во время создания всей системы в конфигурации указываются параметры создания Cognito UserPool, где будут храниться все данные о зарегистрированных пользователях, а также создается UserPoolClient для предоставления JWT токенов, здесь же указываются все ссылки на веб-приложение, развернутое в Amplify. Стоит заметить, что доступ в данном случае происходит по протоколу https, это позволяет защитить информацию при авторизации пользователей.

AWS Amplify – это сервис, предоставляющий недорогой хостинг веб-сайтов, за кадром используются еще несколько Amazon сервисов, но необходимо лишь настроить все свойства и указать как именно нужно развернуть фронтенд из директории с кодом всего приложения. Также есть возможность указать своё доменное имя.

AWS API Gateway позволяет использовать REST API вместе с Lambda функциями для общения веб-части приложения с базой данных. Вторая версия API Gateway даёт возможность прямо во время получения запроса проверить JWT токен и его подлинность автоматически, это встроенная возможность и требует лишь правильной настройки при запуске. Во время создания API Gateway, в конфигурации указывается провайдер токенов - в данном приложении это AWS Cognito, что позволяет эффективно использовать интеграцию этих двух сервисов облака AWS. 

Все описанные сервисы кроме Amplify создаются и подключаются друг к другу при помощи AWS CloudFormation, так как фронтенд настраивается немного иначе и сначала должен быть скомпилирован в Javascript и собран. CloudFormation позволяет создавать и поддерживать архитектуру в облаке Amazon в виде кода, а также разворачивать все ресурсы одним кликом мыши. Конфигурация каждого сервиса по отдельности тоже указывается в виде кода в CloudFormation template.

Далее перечислены основные npm (node packet manager) команды, доступные в корневой папке проекта:
\begin{enumerate}
\item build --- удаляет собранный проект в папке build/ (если таковая имеется) и запускает процесс сборки проекта с использованием webpack, что позволяет эффективно управлять этим процессом;
\item deploy --- запускает Shell script, который отвечает за полный процесс запуска DAM"=системы в облаке (процесс разворачивания приложения будет подробно рассмотрен в соответствующей главе);
\item start-webpack: запускает сборку проекта и сервер в development конфигурации, в данном случае связи с облачным провайдером не будет, используется для тестирования компонентов пользовательского интерфейса.
\end{enumerate}

\subsection{Хранение JWT токенов}

При работе данного программного продукта существенным фактором является правильное управление состоянием React приложения. Для этой цели используется Redux библиотека, позволяющая централизованно управлять общим хранилищем веб-приложения, где содержится такая информация, как: токен авторизации, токен идентификации и переменная, отвечающая за состояние загрузки страниц. В работе благодаря использованию Redux было эффективным образом реализовано получение доступа к этим данным из любой части SPA, написанного на React, а также их обновление. Вся работа с JWT токенами сопровождается обращением к reducer, который обеспечивает отслеживаемое и определенное изменение общего состояния приложения, связанного с авторизацией пользователя.

В файле reducer.ts находиться вся логика обработки событий, связанных с получением и сохранением JWT токенов.

\subsection{API Gateway}

Весь процесс общения пользовательского интерфейса с базой данных происходит через API приложения, точкой доступа к которому является AWS API Gateway. Этот сервис предоставляет endpoint для отправления запросов с клиентской части. Стоит заметить, что в конфигурации при разворачивании DAM"=системы указывается разрешенный источник этих запросов, где устанавливается тот домен, который предоставляет AWS Amplify и где соответственно находится весь фронтенд. Это позволяет существенно улучшить защиту приложения от атак, так как запросы может отправлять только запущенное по данному адресу React веб-приложение.
\clearpage

% Рассмотрим все доступные API запросы:
% \begin{enumerate}
%     \item /admin 
%     \begin{enumerate}
%         \item POST
%     \end{enumerate}
%     \item /clusters 
%     \begin{enumerate}
%         \item POST
%         \item GET
%         \item /\{proxy*\} 
%         \begin{enumerate}
%             \item GET
%         \end{enumerate}
%         \item DELETE 
%     \end{enumerate}
%     \item /files
%     \begin{enumerate}
%         \item POST
%         \item GET
%         \item /\{proxy*\} 
%         \begin{enumerate}
%             \item GET
%         \end{enumerate}
%         \item DELETE 
%     \end{enumerate}
%     \item /permissions 
%     \begin{enumerate}
%         \item POST
%         \item GET
%         \item /\{proxy*\} 
%         \begin{enumerate}
%             \item GET
%         \end{enumerate}
%         \item DELETE 
%     \end{enumerate}
%     \item /users
%     \begin{enumerate}
%         \item POST
%         \item DELETE 
%     \end{enumerate}
% \end{enumerate}

\subsection{Архитектура бекэнда}
На рисунке \ref{backend} изображены все функции обработки пользовательских запросов. Так как данное приложение разрабатывалось по методологии Serverless, все элементы не нуждаются в серверах: AWS Lambda функции запускаются при помощи AWS API Gateway только лишь при поступлении событий со стороны пользовательского интерфейса, далее эти функции обращаются к базе данных (которая также является Serverless сервисом) и выполняют необходимые действия. Вся деятельность при работе приложения распределена на указанное количество Lambda.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.65]{images/BackEnd.png}
    \caption{-- Схема обработчиков запросов и работы с данными в DAM"=системе}
    \label{backend}
\end{figure}

В S3 хранилище находятся загруженные в DAM-систему файлы, с именами в виде индексов, которые назначает данное приложение при добавлении нового файла в базу данных. При загрузке нового файла на странице UploadFile.tsx происходит обработка метаданных, указанных пользователем, проверяется количество уже занятого места в облаке (если добавление файла приведет к превышению указанного в конфигурации DAM"=системы лимита, загрузка файла завершиться с ошибкой и предложением докупить место в облачном хранилище). Затем, используя AWS JavaScript SDK, происходит загрузка в соответствующее S3 хранилище, созданное при разворачивании системы управления цифровыми активами.

Для работы с DynamoDB используется сервис AWS Lambda, который имеет возможность подключения к AWS API Gateway и каждая из Lambda функций является обработчиком одного или нескольких REST запросов с клиентской части приложения. Распределение нагрузки выполнения этих запросов было удачно реализовано так, чтобы избежать слишком долгой обработки задачи одной функцией, что может вызвать увеличение стоимости, а также чтобы не было огромного количества кода в одном файле, что усложняет поддержку и добавление нового функционала.

Рассмотрим каждую Lambda-функцию и её задачи.

Обработчик запросов работы с информацией о пользователях DAM"=системы: UsersHandler.py. Извлекает из запроса идентификатор пользователя (обработка JWT токена и его расшифровка происходит на стороне AWS API Gateway). Совершает запрос в базу данных на поиск соответствующего пользователя. Удачная реализация состоит в том, что нет необходимости прикреплять обработчик на сервис AWS Cognito при создании нового пользователя. Так как Lambda функция может быть запущена только через API Gateway, который предварительно проверяет JWT токен на подлинность, то при отсутствии записи о пользователе в базе данных, текущий обработчик сразу может сделать вывод, что необходимо добавить новую запись в базу данных, так как JWT токен подтверждает что идентификатор является подлинным. Если же данный пользователь уже занесен в базу данных, то этот обработчик вернет в качестве ответа роль этого пользователя.

Обработчик запросов работы с кластерами пользователя: ClustersHandler.py. Извлекает из запроса идентификатор пользователя. Если это POST запрос и в теле запроса нет идентификатора кластера, это говорит о том, что необходимо создать новую smart-папку. Генерируется уникальный идентификатор нового кластера и в базу данных добавляется запись с указанием имени, идентификатора кластера и пользователя, который им владеет. Если это GET запрос и параметров запроса нет, то в базу данных отправляется запрос найти все smart-папки указанного пользователя. Если же параметры запроса указаны, то необходимо найти именно тот кластер, идентификатор которого установлен, а также данная функция определяет, является ли пользователь, запрашивающий данный кластер, его владельцем.

Обработчик запросов работы с метаданными файлов DAM"=системы: FilesHandler.py. Извлекает из запроса идентификатор пользователя, если это POST запрос и в теле запроса поле "action" пустое, это говорит о том, что необходимо добавить файл в указанный кластер. Генерируется уникальный идентификатор новой записи о метаданных файла и в базу данных формируется транзакция, добавляющая как сам файл, так и информацию о том, в какой кластер он был добавлен, по той причине, что нельзя добавить файл не указав к какой smart-папке он относится. Далее происходит обновление записи о метаданных файла - указываются все пользовательские теги. Удачная реализация состоит в том, что при возникновении ошибки хотя бы в одном из этих действий, оба будут отменены так как это транзакция и Lambda-функция вернет сообщение об ошибке. Если это POST запрос и в теле запроса поле action равно addFileToCluster, то в базу данных отправляется запрос на создание записи кластер"=файл, тем самым метаданные указанного файла привязываются к соответствующему кластеру. Все значения идентификаторов извлекаются из тела запроса. Если это GET запрос и параметров запроса нет, то необходимо найти все файлы, загруженные пользователем, идентификатор которого был получен в самом начале работы Lambda"=функции. При поступлении GET запроса с параметром calcUsedSize=true, происходит подсчет общего использованного места в облаке данным пользователем. Благодаря хранению размера файла появляется возможность быстро и эффективно произвести данную операцию. При поступлении GET запроса с параметром clusterId, рассматриваемая функция возвращает все метаданные файлов, которые привязаны к соответствующему кластеру. Сначала в базу данных отправляется запрос найти все записи кластер"=файл для указанного идентификатора smart-папки. Затем, проходя по каждому из элементов в ответе, в базу данных поступает новый запрос на поиск соответствующих метаданных файла. После этого вся информация отправляется на пользовательский интерфейс. При поступлении DELETE запроса из базы данных удаляется соответствующая информация о файле или связка кластер"=файл (при откреплении файла от smart-папки).

Аналогично работает функция управления правами на использование smart-папок PermissionsHandler.py. Функции удаления записей из базы данных (ClustersDeleteHandler, UsersDeleteHandler) работают по той же системе, как и удаление в FilesHandler.py.

Стоит также заметить, что код Lambda"=функций эффективно обрабатывает все возможные ошибки при работе с базой данных DynamoDB и передает ответ пользовательскому интерфейсу, который отображает детали возникшей ошибки.

\subsection{База данных DAM"=системы}
На рисунке \ref{dbSchema} изображена схема используемой базы данных - атрибуты, их названия, а также как именно они связаны между собой и с помощью каких полей происходит агрегация данных при различных запросах (global и local secodary indexes).
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.65]{images/DbSchema.png}
    \caption{-- Схема базы данных}
    \label{dbSchema}
\end{figure}

В вышеупомянутой схеме указывается как распределена вся информация по таблице во время работы приложения. Рассмотрим более подробно процесс агрегации данных.

Использование основных Primary Key и Sort Key таблицы DAM"=системы в DynamoDB. Рассмотрим запрос на получение кластера по указанному идентификатору.
\begin{lstlisting}
query_params = {
    'TableName': 'CloudNativeDAM_DB',
    'ExpressionAttributeNames': {'#ID': 'ID', '#SK': 'SK'},
    'ExpressionAttributeValues': {':id': {'S': cluster_id},':sk': {'S': cluster_id}},
    'KeyConditionExpression': '#ID = :id AND #SK = :sk'
}
\end{lstlisting}
TableName - имя таблицы, так как эффективность DynamoDB позволяет использовать для всех операций DAM"=системы одну таблицу, значение этого параметра будет всегда равно названию системы управления цифровыми активами.

ExpressionAttributeNames - переименование названий атрибутов во избежание конфликтов строковых обозначений. Здесь происходит обращение к Primary Key "ID" и к Sort Key "SK".

ExpressionAttributeValues - значения атрибутов, по которым производиться поиск. В данном случае для ":id" и для ":sk" устанавливается строковое значение (о чем символизирует символ 'S') идентификатора кластера.

KeyConditionExpression - выражение поиска, в котором указываются ExpressionAttributeNames и ExpressionAttributeValues. Здесь атрибуты "ID" и "SK" должны быть одновременно равны ":id" и ":sk" соответственно.

Как видно из схемы базы данных Primary Key "ID" и Sort Key "SK" нужны для хранения различных типов данных в одной таблице - если "ID" и "SK" начинаются с \quotes{Cluster\#} , то в данной строке будет храниться вся информация о кластере (владелец, имя и тд). Если же "ID" начинается с \quotes{Cluster\#}, но "SK" начинается с \quotes{File\#}, то здесь подчеркивается добавление определенного файла в заданную smart-папку. Аналогично для "SK" начинающегося с \quotes{Permission\#} - права, закрепленные за конкретным кластером.

Использование GSI-1 (Data-index) для случая, когда появляется необходимость использовать другое поле в качестве Primary Key для агрегации необходимых данных (получить все кластеры для указанного пользователя). Так как Primary Key "ID" и Sort Key "SK" таблицы отвечают за тип записи в базе данных, то обращение к атрибуту, в котором содержится информация о владельце кластера не может быть выполнена, используя эту пару ключей. По этой причине был создан Global Secondary Index с Primary Key "Data" и с Sort Key "SK". Как можно заметить по схеме базы данных - в поле "Data" хранятся совершенно различные данные.

\clearpage

Рассмотрим запрос на получение всех кластеров для указанного пользователя.
\begin{lstlisting}
query_params = {
    'TableName': 'CloudNativeDAM_DB',
    'IndexName': 'Data-index',
    'ExpressionAttributeNames': {'#C_ID': 'SK', '#OWN': 'Data'},
    'ExpressionAttributeValues': {':Cid': {'S': 'CLUSTER#'},':Uid': {'S': requester_cognito_user_id}},
    'KeyConditionExpression': '#OWN = :Uid AND begins_with(#C_ID, :Cid)'
}
\end{lstlisting}

В данном случае ExpressionAttributeNames указывают на использование поля "Data". В ExpressionAttributeValues устанавливается критерий поиска, \quotes{:Cid='CLUSTER\#'}, так как значение поля "SK" должно начинаться с \quotes{CLUSTER\#}, таким образом можно однозначно сказать, что эта строка несет в себе информацию о кластере. KeyConditionExpression находит все записи в базе данных, где "Data" равна идентификатору владельца кластера, а поле "SK" начинается с \quotes{CLUSTER\#}.

Таким образом, по основному ключу, в котором хранится информация различных типов, есть способ отфильтровать данные по атрибуту "SK". В терминах AWS DynamoDB этот эффективный подход называется GSI overloading, что позволяет в одной таблице хранить данные, которые в традиционных реляционных базах данных приходилось хранить в разных.

Использование GSI-2 (File-Clusters-index). В базах данных существует еще одно отношение: многие ко многим, что в данной программе позволяет получить все кластеры, в которых находиться определенный файл, таким образом, обеспечивая обратную зависимость файл"=кластер. Для решения этой проблемы создается второй Global Secondary Index - \quotes{File-Clusters-index}, у которого ключи являются обратной парой основной таблицы: Primary Key - это "SK"\ , а Sort Key - это "ID".

\clearpage

Рассмотрим запрос на получение всех кластеров в которые был помещен указанный файл.
\begin{lstlisting}
query_params = {
    'TableName': 'CloudNativeDAM_DB',
    'IndexName': 'File-Clusters-index',
    'ExpressionAttributeNames': {'#C_ID': 'ID', '#F_ID': 'SK'},
    'ExpressionAttributeValues': {':Cid': {'S': 'CLUSTER#'},':Fid': {'S': file_id}},
    'KeyConditionExpression': '#F_ID = :Fid AND begins_with(#C_ID, :Cid)'
}
\end{lstlisting}

Как видно из кода, этот случай аналогичный первому, но выражения, связанные с файлами, поменялись местами с выражениями, связанными с кластерами.

Необходимость использования этого GSI обусловливается тем, что Primary Key всегда должен быть указан, по нему нет возможности запустить функцию "begins\_with", так как эта функция может быть использована только на Sort Key.

На рисунке \ref{gsis} изображены все индексы базы данных и информация о них.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.65]{images/gsis.jpg}
    \caption{-- Индексы в базе данных}
    \label{gsis}
\end{figure}

\subsection{Автоматизация разворачивания приложения}

Одним из основных преимуществ разработанного программного продукта является его автоматическое разворачивание в облачном провайдере. Для запуска достаточно начать выполнение одного Shell script, который включает в себя все аспекты инфраструктуры в AWS, а также подключения пользовательского интерфейса к ней.

Рассмотрим данный процесс более подробно. Для начала стоит заметить, что все облачные ресурсы находятся в так называемом template и выполнены с помощью языка Yaml. Сервис AWS CloudFormation использует этот template для создания всех указанных и сконфигурированных ресурсов в выбранном аккаунте Amazon Web Services. 

Далее перечислены компоненты файла InitialCloudFormationTemplate.yml:
\begin{enumerate}
\item ключи доступа к S3 хранилищу, в котором находятся все загруженные в DAM"=систему файлы;
\item полное описание API Gateweay, все методы и точки доступа, какие Lambda"=функции закреплены за каждым из REST запросов, права использования в AWS аккаунте для каждой из функций, а также описание интеграции предоставления JWT токенов из AWS Cognito;
\item путь к коду каждой из Lambda"=функций, так как это Serverless приложение, сам код будет архивирован и загружен в облако чуть позже;
\item все AWS IAM права для работы Lambda"=функций;
\item конфигурация сервиса Cognito для хостинга пользовательского интерфейса и интеграции с API Gateway, используя JWT токены;
\item настройка AWS Amplify;
\item значения на выход после создания ресурсов в облаке для дальнейшей настройки приложения и интеграции с AWS (идентификатор Amplify приложения, ключи доступа к S3, а также API Gateway endpoint и ссылка для регистрации).
\end{enumerate}


В корне репозитория с кодом данной DAM-системы содержится файл fullDeploy.sh, позволяющий запустить процесс, этапы которого перечислены ниже:
\begin{enumerate}
\item упаковка вышеупомянутого InitialCloudFormationTemplate.yml template"=файла и кода всех функций;
\item разворачивание упакованного template через AWS CloudFormation;
\item запуск generate\_config\_script.py для генерации конфигурационного файла для интеграции пользовательского интерфейса с облаком;
\item запуск generate\_amplify\_deployment\_script.py для генерации файла автоматического создания Amplify окружения, где указывается идентификатор созданного приложения;
\item далее происходит инициализация amplify в локальной папке с кодом проекта;
\item используя утилиту expect для Linux, в облаке создается хостинг инициализированного Amplify приложения;
\item последний шаг автоматизации - опубликовать пользовательский интерфейс, используя утилиту amplify.
\end{enumerate}

Как только последний шаг завершит своё выполнение, появляется возможность перейти по указанному адресу и попасть на основную страницу фронтенда приложения. Удачная реализация автоматизации разворачивания приложения предоставляет огромное количество значимых преимуществ - уменьшение ошибок при подключении DAM"=системы, огромное ускорение процесса дельнейшей разработки, упрощение процесса тестирования и так далее.

\subsection{Поиск среди загруженных файлов}
Данная система использует продвинутый сервис для поиска - OpenSearch, это модернизированная компанией Amazon версия программы с открытым исходным кодом, поддерживающая интеграцию с многими другими сервисами AWS. Была создана функция, индексирующая все добавленные файлы и их метаданные -- это позволяет осуществлять расширенный поиск. Например, по имени файла или по существованию тега, не обязательно по конкретному его значению. Все найденные элементы будут возвращены по релевантности. На рисунке \ref{searchExample} изображен пример поиска по метаданным.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.35]{images/ui/4_SearchExample.png}
    \caption{-- Поиск по метаданным}
    \label{searchExample}
\end{figure}

Полная архитектура приложения в облаке AWS, с учетом обработки поисковых запросов представлена на рисунке \ref{fullAwsArch}.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.55]{images/fullArch.png}
    \caption{-- Полная архитектура DAM-системы в AWS}
    \label{fullAwsArch}
\end{figure}

\subsection{Пример работы приложения}

После успешной развертки DAM-системы, перейдя по ссылке на хостинг можно будет увидеть главную страницу, с которой, нажав на соответствующую кнопку, можно перейти на страницу авторизации, предоставляемой сервисом AWS Cognito. 

Далее перечислены доступные зарегистрированному пользователю действия:
\begin{enumerate}
\item посмотреть все загруженные файлы и распределить их по папкам;
\item создать новую smart-папку (рисунок \ref{personalPageMvp}) и увидеть все присутствующие кластеры;
\item перейти на страницу с отображением всех кластеров (smart-папок), которые этот пользователь может видеть, то есть те, на просмотр которых у данного пользователя есть права;
\item удалить полностью свой аккаунт со всеми файлами и smart-папками.
\end{enumerate}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.27]{images/mvp/1_CreateNewCluster.png}
    \caption{-- Создание нового кластера}
    \label{personalPageMvp}
\end{figure}

Перейдя на страницу просмотра кластера, пользователь увидит все доступные ему права – скачивание, загрузка в облако, удаление и выдача прав другим пользователям. Также будет возможность загрузить файл. При нажатии на кнопку \quotes{Upload File} откроется новая страница, где можно будет добавить любое количество метаданных к загружаемому файлу как показано на рисунке \ref{fileUpload}.

Также на странице просмотра кластера есть возможность выдать указанные права на доступ к этой smart-папке выбранному пользователю -- рисунок \ref{addPermissions}.

Другой пользователь, с которым поделились доступом к smart-папке может увидеть этот кластер, если нажмет на главной странице своего профиля на кнопку “See shared with me clusters”. Выбрав нужную папку, этот второй аккаунт будет иметь только те права, которые были указаны при добавлении доступа первым аккаунтом как показано на рисунке \ref{sharedCluster}.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.4]{images/mvp/2_ExampleFileUpload.png}
    \caption{-- Пример загрузки файла с указанием метаданных}
    \label{fileUpload}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.35]{images/mvp/3_GivePermissions.png}
    \caption{-- Выдача прав на владение кластером пользователю}
    \label{addPermissions}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.6]{images/mvp/4_SharedCluster.png}
    \caption{-- Просмотр кластера пользователем с ограниченными правами}
    \label{sharedCluster}
\end{figure}

